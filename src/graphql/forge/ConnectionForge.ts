import {
  GraphQLOutputType,
  GraphQLInputType,
  GraphQLScalarType,
  GraphQLInterfaceType,
  GraphQLNonNull,
  GraphQLObjectType,
  GraphQLFieldConfig,
  GraphQLArgumentConfig,
  GraphQLResolveInfo,
  GraphQLEnumType,
  GraphQLEnumValueConfig,
  GraphQLList,
  GraphQLBoolean,
  GraphQLInt,
  GraphQLString,
  Kind,
} from 'graphql'

import { Paginator, Condition } from '../../catalog'
import memoize from '../utils/memoize'
import buildObject from '../utils/buildObject'
import * as formatName from '../utils/formatName'
import TypeForge from './TypeForge'
import CollectionForge from './CollectionForge'

class ConnectionForge {
  constructor (
    private _typeForge: TypeForge,
  ) {}

  /**
   * Creates a connection field by using a paginator.
   *
   * The reason we have a `gqlType` argument instead of generating one from our
   * `Paginator` object is that because `TypeForge` doesnâ€™t always generate the
   * correct type. `TypeForge` generates the lowest common denominator type. A
   * good example is collections. The type generated by `TypeForge` for a
   * collection is a basic object type with all the appropriate fields.
   * However, we actually want a type for our collection objects that has some
   * *extra* fields. Therefore weâ€™d have to pass in that custom type here
   * instead of letting a `TypeForge` generate it.
   */
  public createField <TValue, TCursor, TCondition>(
    paginator: Paginator<TValue, TCursor>,
    config: ConnectionFieldConfig<TCondition> = {},
  ): GraphQLFieldConfig<any, Connection<TValue, TCursor>> {
    const paginatorName = paginator.getName()
    const gqlConnectionType = this._getConnectionType(paginator)
    const gqlOrderByEnum = this._getOrderByEnumType(paginator)

    // This is the type of all the connection arguments.
    type ConnectionArgs = {
      orderBy?: Paginator.Ordering,
      before?: NamespacedCursor<TCursor>,
      after?: NamespacedCursor<TCursor>,
      first?: number,
      last?: number,
      condition?: TCondition,
    }

    return {
      type: gqlConnectionType,
      // TODO: description
      args: buildObject<GraphQLArgumentConfig<any>>([
        ['orderBy', {
          type: gqlOrderByEnum,
          defaultValue: paginator.getDefaultOrdering(),
          // TODO: description
        }],
        ['before', {
          type: ConnectionForge._cursorType,
          // TODO: description
        }],
        ['after', {
          type: ConnectionForge._cursorType,
          // TODO: description
        }],
        ['first', {
          type: GraphQLInt,
          // TODO: description
        }],
        ['last', {
          type: GraphQLInt,
          // TODO: description
        }],
        config.conditionType && ['condition', {
          type: config.conditionType,
          // TODO: description
        }],
      ]),
      // Note that this resolver is an arrow function. This is so that we can
      // keep the correct `this` reference.
      resolve: async (
        source: any,
        args: ConnectionArgs,
        context: any,
        info: GraphQLResolveInfo<any, any>,
      ): Promise<Connection<TValue, TCursor>> => {
        const {
          orderBy: ordering,
          before: beforeCursor,
          after: afterCursor,
          first,
          last,
          condition: argCondition,
        } = args

        // Throw an error if the user is trying to use a cursor from another
        // paginator.
        if (beforeCursor && beforeCursor.paginatorName !== paginatorName)
          throw new Error('`before` cursor can not be used with this connection.')
        if (afterCursor && afterCursor.paginatorName !== paginatorName)
          throw new Error('`after` cursor can not be used with this connection.')

        // Throw an error if the user is trying to use a cursor from another
        // ordering. Note that if no ordering is defined we expect the
        // `orderingName` to be `null`. This is because when we deserialize the
        // base64 encoded JSON any undefineds will become nulls.
        if (beforeCursor && beforeCursor.orderingName !== (ordering ? ordering.name : null))
          throw new Error('`before` cursor can not be used for this `orderBy` value.')
        if (afterCursor && afterCursor.orderingName !== (ordering ? ordering.name : null))
          throw new Error('`after` cursor can not be used for this `orderBy` value.')

        // Get our condition from the condition input type. If we had no
        // condition or we had no condition config, the condition will just be
        // `true`. Everything passes! ðŸŽ‰
        const condition: Condition = config.getCondition
          ? config.getCondition(source, argCondition)
          : true

        // Construct the page config.
        const pageConfig: Paginator.PageConfig<TCursor> = {
          beforeCursor: beforeCursor && beforeCursor.cursor,
          afterCursor: afterCursor && afterCursor.cursor,
          first,
          last,
          ordering,
          condition,
        }

        // Gets the optimizations for this `Paginator#readPage` request from
        // the GraphQL resolution info.
        const optimizations = getOptimizations(info)

        // Finally, actually get the page data.
        const page = await paginator.readPage(context, pageConfig, optimizations)

        return {
          paginator,
          ordering,
          // We pass on the condition as it is used by the `Paginator#count`
          // method.
          condition,
          page,
        }
      },
    }
  }

  /**
   * Creates a concrete GraphQL connection object type.
   */
  @memoize
  private _getConnectionType <TValue, TCursor>(
    paginator: Paginator<TValue, TCursor>,
  ): GraphQLObjectType<Connection<TValue, TCursor>> {
    const gqlType = this._typeForge.getOutputType(paginator.getType())
    const gqlEdgeType = this._getEdgeType(paginator)

    return new GraphQLObjectType<Connection<TValue, TCursor>>({
      name: formatName.type(`${paginator.getName()}-connection`),
      // TODO: description
      isTypeOf: value => value.paginator === paginator,
      fields: {
        pageInfo: {
          type: new GraphQLNonNull(ConnectionForge._pageInfoType),
          resolve: source => source,
          // TODO: description
        },
        totalCount: {
          type: GraphQLInt,
          resolve: ({ condition }, args, context) => paginator.count(context, condition),
          // TODO: description
        },
        edges: {
          type: new GraphQLList(gqlEdgeType),
          resolve: ({ paginator, ordering, page }): Array<Edge<TValue, TCursor>> =>
            page.values.map(({ cursor, value }) => ({ paginator, ordering, cursor, value })),
          // TODO: description
        },
        nodes: {
          type: new GraphQLList(gqlType),
          resolve: ({ page }): Array<TValue> =>
            page.values.map(({ value }) => value),
          // TODO: description
        },
      },
    })
  }

  /**
   * Creates a concrete GraphQL edge object type.
   */
  @memoize
  private _getEdgeType <TValue, TCursor>(
    paginator: Paginator<TValue, TCursor>,
  ): GraphQLObjectType<Edge<TValue, TCursor>> {
    const paginatorName = paginator.getName()
    const gqlType = this._typeForge.getOutputType(paginator.getType())

    return new GraphQLObjectType<Edge<TValue, TCursor>>({
      name: formatName.type(`${paginator.getName()}-edge`),
      // TODO: description
      isTypeOf: value => value.paginator === paginator,
      fields: {
        cursor: {
          type: new GraphQLNonNull(ConnectionForge._cursorType),
          resolve: ({ ordering, cursor }): NamespacedCursor<TCursor> => ({
            paginatorName,
            orderingName: ordering ? ordering.name : null,
            cursor,
          }),
          // TODO: description
        },
        node: {
          type: gqlType,
          resolve: ({ value }) => value,
          // TODO: description
        },
      },
    })
  }

  /**
   * Creates a GraphQL type which can be used by the user to select an ordering
   * strategy.
   */
  @memoize
  private _getOrderByEnumType <TValue, TCursor>(
    paginator: Paginator<TValue, TCursor>,
  ): GraphQLEnumType<Paginator.Ordering> {
    return new GraphQLEnumType<Paginator.Ordering>({
      name: formatName.type(`${paginator.getName()}-order-by`),
      // TODO: description
      values: buildObject<GraphQLEnumValueConfig<Paginator.Ordering>>(
        paginator.getOrderings().map<[string, GraphQLEnumValueConfig<Paginator.Ordering>]>(ordering =>
          [formatName.enumValue(ordering.name), { value: ordering }]
        )
      ),
    })
  }

  /**
   * Takes a namespaced cursor and serializes it into a base64 encoded
   * string.
   */
  private static _serializeCursor ({ paginatorName, orderingName, cursor }: NamespacedCursor<any>): string {
    return new Buffer(JSON.stringify([paginatorName, orderingName, cursor])).toString('base64')
  }

  /**
   * Deserializes a base64 encoded namespace cursor into the correct data type.
   */
  private static _deserializeCursor (serializedCursor: string): NamespacedCursor<any> {
    const [paginatorName, orderingName, cursor] = JSON.parse(new Buffer(serializedCursor, 'base64').toString())
    return { paginatorName, orderingName, cursor }
  }

  /**
   * The cursor type is a scalar string type that represents a single edge in a
   * connection.
   *
   * @private
   */
  private static _cursorType: GraphQLScalarType<NamespacedCursor<any>> = (
    new GraphQLScalarType<NamespacedCursor<any>>({
      name: 'Cursor',
      // TODO: description
      serialize: value => ConnectionForge._serializeCursor(value),
      parseValue: value => ConnectionForge._deserializeCursor(value),
      parseLiteral: ast => ast.kind === Kind.STRING ? ConnectionForge._deserializeCursor(ast.value) : null
    })
  )

  /**
   * The page info type contains information about the current page of results
   * returned by the connection.
   *
   * @private
   */
  private static _pageInfoType = (
    new GraphQLObjectType<Connection<any, any>>({
      name: 'PageInfo',
      // TODO: description
      fields: {
        hasNextPage: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: ({ page }) => page.hasNext,
          // TODO: description
        },
        hasPreviousPage: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: ({ page }) => page.hasPrevious,
          // TODO: description
        },
        startCursor: {
          type: ConnectionForge._cursorType,
          resolve: ({ paginator, ordering, page }): NamespacedCursor<any> => ({
            paginatorName: paginator.getName(),
            orderingName: ordering ? ordering.name : null,
            cursor: page.values[0].cursor,
          }),
          // TODO: description
        },
        endCursor: {
          type: ConnectionForge._cursorType,
          resolve: ({ paginator, ordering, page }): NamespacedCursor<any> => ({
            paginatorName: paginator.getName(),
            orderingName: ordering ? ordering.name : null,
            cursor: page.values[page.values.length - 1].cursor,
          }),
          // TODO: description
        },
      },
    })
  )
}

export default ConnectionForge

/**
 * When creating a connection field, the user has the option to allow
 * conditions with that connection. If the user chooses to use conditions,
 * they must provide this extra config object.
 */
type ConnectionFieldConfig<TCondition> = {
  conditionType?: GraphQLInputType<TCondition>,
  getCondition?: (source: any, conditionValue: TCondition | undefined) => Condition,
}

/**
 * This is the type for the value of all connection types. It contains the
 * paginator for identification, ordering for cursor serialization, condition
 * for fetching the correct count, and of course the actual page of data.
 *
 * @private
 */
interface Connection<TValue, TCursor> {
  paginator: any
  ordering: Paginator.Ordering | undefined
  condition: Condition
  page: Paginator.Page<TValue, TCursor>
}

/**
 * This is the type for the value of all edge types. Similarly to the
 * connection value it has a paginator for identification, ordering for cursor
 * serialization, and of course a value and its associated cursor.
 *
 * @private
 */
interface Edge<TValue, TCursor> {
  paginator: any
  ordering: Paginator.Ordering | undefined
  cursor: TCursor
  value: TValue
}

/**
 * A namespaced cursor is a cursor with identifying information. A cursor that
 * was returned by one paginator can not be used by another paginator and a
 * cursor created with one ordering can not be used with another ordering.
 * Therefore we need to serialize this information with our cursor to make the
 * appropriate checks and ensure the cursor is valid for our resolve context.
 *
 * @private
 */
type NamespacedCursor<TCursor> = {
  paginatorName: string,
  orderingName: string | null,
  cursor: TCursor,
}

/**
 * Will create a paginator optimizations object from the `GraphQLResolveInfo`
 * object.
 */
// TODO: Test this lots.
function getOptimizations <TValue>(info: GraphQLResolveInfo<any, any>): Paginator.Optimizations<TValue> {
  return {
    fieldNames:
      info.fieldASTs
        // Filter out field ASTs with arguments. Probably donâ€™t want those.
        .filter(field => !field.arguments || field.arguments.length === 0)
        // Map to just the string name.
        .map(field => field.name.value),
  }
}
